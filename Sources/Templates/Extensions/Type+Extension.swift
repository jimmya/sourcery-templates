import SourceryRuntime

extension Type {

    var initMethods: [Method] {
        methods.filter { ($0.isInitializer || $0.isFailableInitializer) && !$0.isConvenienceInitializer }
    }

    var autoRegisterTypes: [Type]? {
        let autoRegisterTypes = types.all.filter {
            $0.implements.contains(where: { $0.value == self }) && $0.isAutoRegister
        }
        return autoRegisterTypes.isEmpty ? nil : autoRegisterTypes
    }

    func generateStub(types: Types, annotations: Annotations) -> [String] {
        var lines: [String] = []
        lines.append("\(accessLevel) extension \(name) {")

        let initMethodLines = initMethods.enumerated().map { index, method in
            generateInitMethodStub(types: types, index: index, method: method, annotations: annotations)
        }
        lines.append(contentsOf: initMethodLines.joined(separator: [.emptyLine]))

        // If we have an explicit init method the compiler won't synthesize a memberwise initialiser.
        if initMethods.isEmpty {
            lines.append(contentsOf: generateMemberwiseInitMethodStub(types: types, annotations: annotations))
        }
        lines.append("}")
        return lines
    }
}

private extension Type {
    /// Generate a stub for an initialiser that's generated by default for `structs` that don't have explicit initialisers.
    /// The init is generated based on the order of the properties of the struct.
    func generateMemberwiseInitMethodStub(types: Types, annotations: Annotations) -> [String] {
        var lines: [String] = []
        lines.append("static func stub(".indent())
        let availableVariables = storedVariables.filter { !$0.hasDefaultValue }
        let variableLines = availableVariables.map { variable in
            variable.generateInitAssignment(types: types, annotations: annotations).indent(level: 2)
        }
        let joinedVariableLines = variableLines.joined(separator: "," + .newLine)
        lines.append(joinedVariableLines)
        lines.append(") -> \(name) {".indent())
        lines.append("\(name)(".indent(level: 2))
        let variableAssignmentLines = availableVariables.map { variable in
            "\(variable.name): \(variable.name)".indent(level: 3)
        }
        let joinedVariableAssignmentLines = variableAssignmentLines.joined(separator: "," + .newLine)
        lines.append(joinedVariableAssignmentLines)
        lines.append(")".indent(level: 2))
        lines.append("}".indent())
        return lines
    }

    /// Generate a stub for an explicit init method. If a type has multiple init methods the stub method will be suffixed with a number.
    func generateInitMethodStub(types: Types, index: Int, method: Method, annotations: Annotations) -> [String] {
        let implicitlyUnwrappedVariables = storedVariables.filter { $0.isImplicitlyUnwrappedOptional }
        var lines: [String] = []
        lines.append("static func \(stubMethodName(index: index, count: initMethods.count))(".indent())
        var initParameters: [String] = method.parameters.map { $0.generateInitAssignment(types: types, annotations: annotations).indent(level: 2) }
        initParameters.append(contentsOf: implicitlyUnwrappedVariables.map { $0.generateInitAssignment(types: types, annotations: annotations).indent(level: 2) })
        lines.append(initParameters.joined(separator: "," + .newLine))
        lines.append(") -> \(name)\(method.isFailableInitializer ? "?" : "") {".indent())
        let parameterNames = method.parameters.map { parameter in
            parameter.argumentLabel ?? parameter.name
        }
        lines.append(generateStubbableInit(parameterNames: parameterNames))
        lines.append("}".indent())
        return lines
    }

    func generateStubbableInit(parameterNames: [String]) -> String {
        let implicitlyUnwrappedVariables = storedVariables.filter { $0.isImplicitlyUnwrappedOptional }
        let containsImplicitlyUnwrappedOptionals = !implicitlyUnwrappedVariables.isEmpty

        guard !parameterNames.isEmpty || containsImplicitlyUnwrappedOptionals else {
            return "\(name)()"
        }

        var lines: [String] = []
        let variableDeclaration = self is Struct ? "var" : "let"
        var objectInit: String = containsImplicitlyUnwrappedOptionals ? "\(variableDeclaration) object = \(name)(" : "\(name)("
        if parameterNames.isEmpty {
            objectInit.append(")")
        }
        lines.append(objectInit.indent(level: 2))

        let parameterLines = parameterNames.map { "\($0): \($0)".indent(level: 3) }
        lines.append(parameterLines.joined(separator: "," + .newLine))
        if !parameterLines.isEmpty {
            lines.append(")".indent(level: 2))
        }

        if containsImplicitlyUnwrappedOptionals {
            let implicitUnwrappedVariableLines = implicitlyUnwrappedVariables.map { "object.\($0.name) = \($0.name)".indent(level: 2) }
            lines.append(implicitUnwrappedVariableLines.joined(separator: .newLine))
            lines.append("return object".indent(level: 2))
        }

        return lines.joined(separator: .newLine)
    }

    func stubMethodName(index: Int, count: Int) -> String {
        count > 1 ? "stub\(index)" : "stub"
    }
}
